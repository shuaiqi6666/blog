---
sidobar: true
---

# JavaScript异步编程

## 前言

总所周知，目前主流的JavaScript环境，都是以单线程的模式去执行的JavaScript代码。那JavaScript采用单线程模式的原因和它最早的设计初衷有关。最早JavaScript语言就是一门设计在浏览器端运行的脚本语言，它的目的就是为了实现页面上的动态交互。而实现页面交互的的核心就是DOM操作。决定了其做为单线程的本质，单线程意味着代码的执行顺序必须按顺序执行，在同一时间只能处理一个任务。

假设JavaScript是对线程的，一个线程执行删除DOM元素，另一个执行修改该元素，那么会导致复杂的同步逻辑。

## 同步编程

同步模式就是代码从上到下一句一句执行，当前代码任务耗时执行会阻塞后面代码的执行。

::: tip
同步编程，即是典型的请求-响应模型，当请求调用一个函数或方法后，需等待其响应结果返回，然后执行后续代码。
:::


一般情况下，同步编程，代码依次执行，能很好的保证程序的执行，但是在某些场景下，比如读取文件内容，或请求服务器接口数据，需要根据返回的数据内容执行后续操作，读取文件和请求接口直到数据返回需要一定的时间，网络越差，耗时越长。如果按照同步编程方式实现，在等待数据返回的这段时间，JavaScript是不能处理其他任务的，此时页面的交互、滚动等任何操作也都会被阻塞。

## 异步编程

由于上面同步编程的限制，对用户显然及其不友好，不可接受的，此时正是异步编程大显身手的场景了。

当使用异步编程时，在等待当前任务的响应返回之前，可以继续执行后面的代码。即当前执行任务不会阻塞后续执行。

::: tip
异步编程，不同于同步编程的请求-响应模式，其是一种事件驱动编程，请求调用函数或方法后，无需等待其响应结果，可以继续执行其他任务，而之前任务响应返回后可以通过状态、通知和回调来通知调用者，
:::

## 回调函数

在最早使用Ajax的时代，js采用的就是回调函数来响应异步操作。 

```js
const xhr = new XMLHttpRequest();
xhr.open('GET', 'localhost:8080');
xhr.onload = function (res) {};
xhr.send();
```

缺点：回调地狱： 当当前操作依赖上一个请求的响应，而下一个请求依赖当前请求的响应，就很容易形成回调地狱，导致代码层层嵌套，难维护。（如下代码）
```js
ajax(url, () => {
    // 处理逻辑
    ajax(url1, () => {
        // 处理逻辑
        ajax(url2, () => {
            // 处理逻辑
        })
    })
})
```
## promise

promise 是回调函数的回调地狱的一种解决方案。

promise对象有两个特点：

1. 一旦状态改变，就不会再变。 

    promise一共有三种状态： pending（进行中）、fulfilled（已成功）、rejected（已失败）。promise的中文意思是承诺，这就好像你妈叫你去打酱油，此时状态时pending状态，你打酱油只有两种结果，一种是打回酱油了，那么就是fulfilled状态；一种是没有打到酱油，那就是rejected状态。所有状态一旦改变就不会在变。

2. 对象的状态不受外界影响。

    promise的状态只有异步的结果才能改变。任何其他操作都无法改变，就好比你妈叫你打酱油，打到了就是成功没打到就是失败，其他人改变不了这个事实。

### 基本用法

## Generator

## Async函数