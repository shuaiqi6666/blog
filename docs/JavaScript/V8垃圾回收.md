---
sidebar: auto
---

# V8引擎垃圾收回机制
 
 

##  前言

V8是谷歌的开源高性能JavaScript和WebAssembly引擎，用C++编写。它用于Chrome和Node.js等。它实现ECMAScript和WebAssembly。Google Chrome使用V8的API，但引擎的内核部分是独立于浏览器之外的。速度是V8追求的主要设计目标之一，它把JavaScript代码直接编译成机器码运行，比起传统的“中间代码+解释器”的引擎，优势不言而喻。

## 为什么需要垃圾回收

+ 防止页面占用内存过大，引起客户端卡顿，甚至无响应。
+ Node使用的也是V8，内存对于后端服务的性能至关重要，因为服务的持久性，后端容易造成内存泄漏。

## V8引擎的内存限制

关于V8引擎的学习和解读，我们从 `Node`中通过 `JavaScript `使用内存时就会发现只能使用部分内存（64位系统下约为`1.4 GB`，32位系统下约为`0.7 GB`），其深层原因是 `V8 `垃圾回收机制的限制所致（如果可使用内存太大，而`V8`在进行垃圾回收时需耗费更多的资源和时间，严重影响`JS`的执行效率。

::: tip 	JavaScript单线程机制
 `JavaScript`主要用途是用于用户交互和操作`DOM`，决定了其做为单线程的本质，单线程意味着代码的执行顺序必须按顺序执行，在同一时间只能处理一个任务。假设`JavaScript`是多线程的，一个线程执行删除`DOM`元素，另一个执行修改该元素，那么会导致复杂的同步逻辑。既然`JavaScript`是单线程的，那么也意味当`V8`执行垃圾回收是，程序中的而其他逻辑要进入暂停状态，直到垃圾回收结束后才会重新执行`JS`逻辑。（虽然在`HTML5`中引入了新的`Web Worker`标准，其作用就是为`JS`创造多线程环境，允许主线程创建`Worker`线程，将一些任务分配给后者运行。但是子线程完全受主线程控制，不能访问浏览器特定的`API`，例如操作`DOM`，因此这个新标准并没有改变`JS`单线程的本质）
:::

::: tip 	垃圾回收机制
垃圾回收本身也是一件非常耗时的操作，浏览器一直处于等待的状态，同时会失去对用户的响应，如果有动画正在运行，也会造成动画卡顿掉帧的情况，严重影响应用程序的性能。因此如果内存使用过高，那么必然会导致垃圾回收的过程缓慢，也就会导致主线程的等待时间越长，浏览器也就越长时间得不到响应
:::
 

 基于以上两点，V8引擎为了减少对应用的性能造成的影响，采用了一种比较粗暴的手段，那就是直接限制堆内存的大小，毕竟在浏览器端一般也不会遇到需要操作几个G内存这样的场景。

 
## V8引擎是如何回收内存
    > V8的垃圾回收策略主要是基于分代式垃圾回收机制，其根据对象的存活时间将内存的垃圾回收进行不同的分代，然后对不同的分代采用不同的垃圾回收算法

### V8的堆内存结构

一个V8进程的内存通常由一下几个块构成：
+ 大对象区（ `large object space` ）

	这里存放体积超过其他区大小的对象，每个对象都有自己的内存，垃圾回收不会移动大对象区。
	
+ map区 （ `map space` ）

	存放 `Cell `和 `Map`，每个区域都是存放相同大小的元素，结构简单。
	
+ 新生代内存区 （ `new space` ）

	大多数的对象都会被分配在这里，这个区域很小但是垃圾回收比较频繁,该区域划分两半（`from`空间和`to`空间），`from`空间用来分配内存，`to`空间用于来及回收时需要保存的数据。
	
+ 老生代内存区 （ `old space` ）

	这里又分为老生代指针区（ `old pointer space`）和老生代内存区（`old data space`），这里只保存原始数据对象，这些对象没有只想其他对象的指针。

	+ 老生代指针区（ `old pointer space`）

		存放GC后surviving的指针对象；最大限制为512MB
		
	+ 老生代内存区（`old data space`）

		存放GC后surviving的数据对象；最大限制为512MB；
		
+ 代码区 （ `code space` ）

	代码对象会被分配到这里，唯一拥有执行权限的内存

![An image](/v8.1.png)

### 新生代内存区

新生代主要存放活动时间较短的对象，由`from`和`to`两个空间组成。内存最大值在32/64位操作系统下内存分别为16MB/64MB。

新生代的垃圾回收机制采用的`scavenge`算法，特点：牺牲空间换取时间，因为新生代大部分对象生命周期比较短，在时间效率上表现可观，所以还是比较适合这种算法，

缺点：`浪费一半的内存进行复制`。

优点：`快`。


#### 新生代算法流程

+ 在`scavenge`算法的具体实现中，主要采用了`cheney`算法，他将新生代内存一分为二，其中处于激活区域我们称之为`From空间`，未激活我们称之为`To空间`；

 ![Alt text](/v8.2.png)
 
+ 这两个空间始终只有一个处于使用状态，另一个处于闲置状态。我们程序中声明的对象首先会分配到`From`空间 

 ![Alt text](/v8.3.png)
 
+ 当进行垃圾回收时，如果`From`空间尚有存活对象，则会被复制到`To`空间进行保存，非存活对象将会被自动回收

 ![Alt text](/v8.4.png)

+ 复制完成后，From空间会和To空间进行一次互换。

 ![Alt text](/v8.5.png)

 



### 老生代内存区

在老生代内存区，主要管理者大量的存活对象，所以采用了新的`mark_sweep`（标记清除）`mark_compact`（标记整理）算法。内存最大值在32/64位操作系统内存分别为0.7G/1.4G。

::: tip
 `mark_sweep`分为标记和清除，在标记阶段遍历堆中所有的对象，标记活着的对象，在清除阶段将死亡的对象进行清除。`mark_sweep`主要通过判断某额对象是否可以被访问到，从而知道该对象是否被回收。
::: 

#### 老生代内存区算法流程

+ 垃圾回收机制会在内部建立一个根列表，用于从根节点出发区寻找可以被访问到的量，比如：在JavaScript中的window全局第项可以看作一个根节点。

::: tip 	以下可以成为根节点 

+ 全局对象
+ 本地函数的局部变量和参数
+ 当前嵌套调用键上的其他函数的变量和参数
:::


+ 然后垃圾回收机制从根节点出发，便利所有访问访问到的根节点，并标记未活动的，根节点不能到达的地方即非活动的，将被标记未垃圾。

 ![Alt text](/v8.6.png)
	
+ 清除被标记成来及的对象，将空间返回给操作系统。

 ![Alt text](/v8.7.png)

+ 经历了`mark_sweep`标记清除的算法后，内存空间肯恶搞出现不连续的状态，因为我们清理的对象的内存地址可能也是不连续的，所以就会出现内存碎片（看到这是不是想起windows系统的碎片整理了哈），导致后面如果需要分配一个大对象而我无法存放，就会提前出发垃圾回收，而提前出发垃圾回收会导致主线程同步任务被暂停，需等待执行完成后才能恢复主线程的任务。而这次的垃圾回收是没有必要的，因为在经历了`mark_sweep`标记清除的算法后老生代中还有很多内存空闲，只不过不连续。

+ `mark_compact`（标记整理）算法主要就是解决内存碎片的问题，回收过程中将死亡对象清除后，会将活动的堆内存往老生代的一端进行移动,移动完清除边界的全部内存。

 ![Alt text](/v8.8.png)

### 对象晋升

::: tip 	说明
当一个对象在新生代区进行多次复制后依然存活，那么他被认为生命周期较长的对象，在下一次进行垃圾回收时就直接转移到老生代中，这种新生代转移到老生代中的方法称之为晋升。
:::

默认情况下，我们创建的对象会存在From空间中，当进行垃圾回收时，再将对象复制到To空间时，会检查该对象是否经历过一次 scavenge算法，如果地址已经发生变化，则将对象转移到老生代区。

 ![Alt text](/v8.9.png)

但是如果此时To空间占比超过25%，则该对象会直接被转移到老生代中。

 ![Alt text](/v8.10.png)

之所以有25%的内存限制是因为To空间在经历过一次Scavenge算法后会和From空间完成角色互换，会变为From空间，后续的内存分配都是在From空间中进行的，如果内存使用过高甚至溢出，则会影响后续对象的分配，因此超过这个限制之后对象会被直接转移到老生代来进行管理。

两个条件整合的流程图

![Alt text](/v8.11.png)

## 优化内存技巧

+ 尽量不要定义全局变量

	在ES5中以var申明的方式会在全局作用域下创建一个变量，或在函数中不以任何生命创建一个变量，都会挂载到window全局对象上
	
```javascript
var arr=[1,3,4];
function num(){
	a = 1;
}
```
+ 全局变量销毁

	在我们写代码时，已知 `x`变量后无用不到，我们就将此变量设置为 `null`

+ 手动清除定时器

	被遗忘的定时器和回调函数会引起整个进程奔溃。

```javascript
var serverData = loadData();
setInterval(function() {
    var renderer = document.getElementById('renderer');
    if(renderer) {
        renderer.innerHTML = JSON.stringify(serverData);
    }
}, 5000);
```

+ 清除DOM的引用

	以往我们在操作DOM元素时，为了避免多次获取DOM元素，我们会将DOM元素存储在一个数据字典中，示例如下：

```javascript
const elements = {
    button: document.getElementById('button')
};

function removeButton() {
    document.body.removeChild(document.getElementById('button'));
}
```

在这个示例中，我们想调用removeButton方法来清除button元素，但是由于在elements字典中存在对button元素的引用，所以即使我们通过removeChild方法移除了button元素，它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对button元素的引用才会被垃圾回收。


