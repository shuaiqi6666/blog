---
sidebar: auto
---


# 数据结构与算法

## 什么是数据结构和算法

::: tip
数据结构是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优的算法。 ---- 中文维基百科
:::

## 为什么要学习算法和数据结构

首要原因是数据结构和算法可以很高效额解决常见的问题，这对你今后所写的代码的质量至关重要（也包括性能，用了不恰当的数据结构和算法，很可能产生性能问题）。

## 数组

几乎所有的变成语言都原生的支持数组类型。因为数组是最简单的内存数据结构。

## 栈数据结构

通过上一节我们知道，可以在数组的任意位置添加或删除元素。然而，有时候还需要一种能在添加或删除元素时进行更多的控制的数据结构。

栈是一种遵从先进后出原则的有序集合。其限制是仅允许字表的一端进行插入和删除运算，这一段称之为栈底，新添加的元素或待删除的元素都保存在栈的同一端，称之为栈顶。在栈里，新元素都靠近栈顶，旧元素都靠近栈底。


::: tip
现实中的例子：

现实生活中就像一堆垒起来的书。 新增书本或拿走书本都是从顶端添加或拿走。 

自助餐的托盘，最新放上去，最先让客人拿走使用
:::

### 程序中什么是使用栈实现的呢？
> 学了这么久的编程，是否听说过函数调用栈、
>
> 我们知道函数之间互相调用，A调用B，B调用C，C调用D
>
> 那么在指定过程中，会先将A压入栈，A没执行完，所以不会弹出栈
>
> 在A执行中调用B，那么会将B压入到栈，这时候B在栈顶，A在栈底
>
> 如果这个时候B执行完，那么B会弹出栈，但是B没有执行完呢？那他就会调用C
>
> 所以C会压栈，并且在栈顶，而C调用了D ，D会压入栈顶，
>
> 所以当前的栈执行的顺序是：栈底 A->B->C->D栈顶
>
> 执行完，弹出栈，C/B/A依次弹出栈
>
> 所以我们有函数调用栈的称呼，就是来自于他们内部的实现机制（通过栈实现的）

### 栈的面试题

有六个元素6,5,4,3,2,1，的顺序（不是一次性进栈），问下列哪一个不是合法的出战顺序（C）

+ A 5 4 3 6 1 2    
+ B 4 5 3 2 1 6   
+ C 3 4 6 5 2 1   
+ D 2 3 4 1 5 6 

### 栈结构的实现（基于数组实现）

```js
function Stack() {
    this.items = [];                        // 栈的属性 
}
Stack.prototype.push = function (value) {    // 添加一个或多个元素到栈顶
    this.items.push(value)
}
Stack.prototype.pop = function () {          // 移除栈顶元素，同时返回被移除的元素
    return this.items.pop()
}
Stack.prototype.peek = function () {         // 查看栈顶元素
    return this.items[this.items.length - 1]
}
Stack.prototype.isEmpty = function () {      // 判断栈是否为空
    return this.items.length == 0
}
Stack.prototype.clear = function () {        // 移除栈中算有的元素
    return this.items = []
}
Stack.prototype.size = function () {         // 返回栈中的个数
    return this.items.length
}
Stack.prototype.toString = function () {     // 转字符串
    let str = '';
    if(this.items.length === 0){
        return str;
    }
    for (let i = 0; i < this.items.length; i++) {
        str += item[i]
    }
    return str
}
```

### 用栈解决问题


#### 将十进制转成二进制

```js
function dec2bin(num){
    var stack = new Stack();
    while(num > 0){
        stack.push(num%2);
        num = Math.floor(num/2)
    }
    var str = '';
    while(!stack.isEmpty()){
        str += stack.pop().toString()
    }
    return str
}

```

## 队列数据结构

::: tip     受限的线性结构
符合先进先出

受限之处在于它只允许在表的前端（front）进行删除操作

而在表的后端（rear）进行插入操作。
:::

生活中有很多类似的队列结构：在银行排队办理业务，在超市排队结账，打印机打印多份资料。


### 队列结构的实现（基于数组实现）

```js
function Queue(){
    this.items = [];    // 属性
}
Queue.prototype.enqueue = function (element){   // 将元素添加到队列中
    this.items.push(element)
}
Queue.prototype.dequeue = function (){          // 从队列中删除前端元素
    this.items.shift()
}
Queue.prototype.front = function (){            // 返回队列中的第一个元素 
    return this.items[0]
} 
Queue.prototype.isEmpty = function (){          // 队列中是否为空
    return this.items.length === 0
}
Queue.prototype.size = function (){             // 返回队列包含的元素个数
    return this.items.length
}
Queue.prototype.toString = function (){         // 将队列转为字符串形式
    let str = '';
    if(this.items.length === 0){
        return str;
    }
    for (let i = 0; i < this.items.length; i++) {
        str += this.items[i]
    }
    return str
} 
```

### 击鼓传花
```js
function passGame( nameList, num){
    var queue = new Queue();                        // 创建一个队列结构
    for(var i = 0; i < nameList.elngth; i++){       // 将所有人依次加入队列
        queue.enqueue(nameList[i])
    }
    while( queue.size() > 1){
        for( var i = 0; i < num-1; i++){            // 开始数
            queue.enqueue(queue.dequeue())          // 不是num时，重新加入队列
        }
        queue.dequeue()                             // 是num时，将其从队列中删除
    }
   return queque.front()
}

```

### 优先级队列

我们知道，普通的队列插入一个元素，数据会被放在后端，并且需要前面所有的元素都处理完后才会处理前面的数据

但是优先级队列，在插入一个元素的时候会考虑该数据的优先级

和其他数据优先级比较

比较完成后，可以得出这个元素在队列中正确的位置

其他处理方式，和基本队列的处理方式一样。

```js
function PriorityQueue(){
    this.items = [];
    function QueueElement(element, priority){
        this.element = element 
        this.priorty = priority
    }
    PriorityQueue.prototype.enqueue = function (element, priority){
        var queueElement = new QueueElement(element, priority) // 创建QueueElement对象
        if(this.items.length == 0){     //  判断队列是否为空
            this.items.push(queueElement)
        }else{
            var added = false
            for(var i = 0; i < this.items.length; i++){
                if(QueueElement.priority < this.items[i].priority){
                    this.items.splice(i, 0, queueElement)
                    added = true
                    break
                }
            }
            if(!added){
                this.items.push(queueElement)
            }
        }
    }
}
PriorityQueue.prototype.enqueue = function (element){   // 将元素添加到队列中
    this.items.push(element)
}
PriorityQueue.prototype.dequeue = function (){          // 从队列中删除前端元素
    this.items.shift()
}
PriorityQueue.prototype.front = function (){            // 返回队列中的第一个元素 
    return this.items[0]
} 
PriorityQueue.prototype.isEmpty = function (){          // 队列中是否为空
    return this.items.length === 0
}
PriorityQueue.prototype.size = function (){             // 返回队列包含的元素个数
    return this.items.length
}
PriorityQueue.prototype.toString = function (){         // 将队列转为字符串形式
    let str = '';
    if(this.items.length === 0){
        return str;
    }
    for (let i = 0; i < this.items.length; i++) {
        str += this.items[i].element + '-' + this.items[i].priority + ' '  
    }
    return str
} 

```

## 链表

### 介绍

链表和数组一样，用于存储一系列的元素，但是链表和数组的实现机制完全不同。

::: tip     数组的缺点
在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。
:::

::: tip     链表的优势
链表中的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。可以充分利用计算机的内存，实现灵活的内存动态管理。

链表不必在创建时就确定大小，并且大小可以无限的衍生下去

链表在插入和删除数据时，时间复杂度可以达到O(1)，相对于数组效率高很多。
:::

::: tip     链表的缺点
链表访问任何一个位置的元素时，都需要从头开始访问（无法跳过第一个元素访问任何一个元素）

无法通过下标直接访问元素，需要从头一个个访问，直接找到对应的元素。
:::

### 链表的实现

```js
function LinkedList(){
    function Node(data){
        this.data = data
        this.next = null
    }
    this.head = null 
    this.length = 0

    LinkedList.prototype.append = function (data){      // 向列表尾部添加一个新的项
        var newNode = new Node(data) 
        if(this.length == 0){   // 是第一个节点 
            this.head = newNode
        } else {
            var current = this.head
            while(current.next){
                current  = current.next
            }
            current.next = newNode
        }
        this.length += 1
    }
    LinkedList.prototype.insert = function (position, data){  // 向列表特定位置添加一个项
        if(position < 0 || position > this.length){
            return false
        }
        var newNode = new Node(data)

        if( position == 0){
            newNode.next = this.head 
            this.head = newNode 
        } else {
            var current = this.head     
            var index = 0
            var previous = null     
            while( index++ < position){
                previous = current  // 当前项
                current = current.next  // 当前项的下一项
            }
            newNode.next = current  // 将插入项的next指向之前在position位置项
            previous.next = newNode // 将 position位置上一项指向插入项
        }
        this.length += 1
        return true
    }
    LinkedList.prototype.get = function (position){         // 获取对应位置的元素
        if( postion <  0 || position >= this.length){
            return null
        }
        var current = this.head
        var index = 0
        while(index++ < position){
            current = current.next
        }
        return current
    }
    LinkedList.prototype.indexOf = function (data){     // 返回元素在位置中的索引，没有就返回 -1
        var current = this.head
        var index = 0 
        while(current){
            if(current.data != data){
                current = current.next
                index++
            }else{
                return index 
            }
           
        }
        return   -1
    }
    LinkedList.prototype.update = function (position, newData){      // 修改某个位置的元素
        if(position < 0 || position >= this.length) return false
        var current = this.head
        var index = 0 
        while(index++ < postion){
            current = current.next
        }
        current.data = newData
        return true
    }
    LinkedList.prototype.removeAt = function (position){    // 从列表中特定的位置移除一项
        if(position < 0 || position >= this.length) return false
        var current = this.head
        var previous = null
        var index = 0
        while(index++ < position){
            previous = current
            current = current.next  // 当前项
        } 
        previous.next = current.next
        this.length -= 1
        return true 
    }
    LinkedList.prototype.remove = function (data){      // 从列表中移除一项
        var position = this.indexOf(data)
        return this.removeAt(position)
    }
    LinkedList.prototype.isEmpty = function (){     // 链表中是否不包含任何元素
        return this.length === 0
    }
    LinkedList.prototype.size = function (){        // 返回链表包含元素的个数
        return this.length
    }
    LinkedList.prototype.toString = function (){    // 向列表尾部添加一个新的项
        var current = this.head
        var listString = ""
        while(current){
            listString += current.data
            current  = current.next  + ' '
        } 
        return  listString
    } 
}


```
 

## 双向链表

单项链表：

+ 只能从头到尾遍历

+ 实现的原理是上一个链表有一个指向下一个的引用

单向链表的缺点

+ 我们可以轻松的到达下一个节点，但是回到上一个节点是很难的；但是，在实际开发中经常会员到需要回到上一个节点的情况。


双向链表优点：

+ 既可以从头到尾遍历，也可以从尾到头遍历

双向链表缺点：

+ 每次插入或删除某个节点时，需要处理四个引用，而不是两个，实现起来比较困难

+ 相对于单向链表，占用内用空间更大 


```js
function DoublyLinkedList(){
    function Node(data){
        this.data = data
        this.prev = null
        this.next = null
    }
    this.head = null
    this.tail = null
    this.length = 0

    DoublyLinkedList.prototype.append = function (data){
        var newNode = new Node(data)
        if(this.length == 0){
            this.head = newNode
            this.tail = newNode
        }else{
            newNode.prev = this.tail
            this.tail.next = newNode
            this.tail = newNode
        }
        this.length += 1
    } 
    DoublyLinkedList.prototype.toString = function (){          
        return this.backwardString()
    }
    DoublyLinkedList.prototype.forwardString = function (){
        var current =this.tail
        var resultString = ''
        while(current){
            resultString += current.data+ ' '
            current = crrent.prev
        }
        return resultString
    }
    DoublyLinkedList.prototype.backwardString = function (){
        var current =this.head
        var resultString = ''
        while(current){
            resultString += current.data+ ' '
            current = crrent.next
        }
        return resultString
    }
    DoublyLinkedList.prototype.insert = function (position, data){      // 在指定位置插入数据
        if( position < 0 || position > this.length) return false
        var newNode = new Node(data)
        if(this.length === 0){
            this.head = newNode
            this.tail = newNode
        }else{
            if( position === 0){    // 在头部插入
                this.head.prev = newNode
                newNode.next = this.head
                this.head = newNode
            }else if(position == this.length){  // 在最后尾部插入
                this.tail.next.next = newNode
                newNode.prev = this.tail.next
                this.tail = newNode
            }else {
                var current = this.head
                var previous = null
                var index = 0
                while(index++ < position){
                    previous = current
                    current = current.next
                }
                newNode.next = current
                current.prev = newNode
                previous.next = newNode
                newNode.prev = previous
            } 
        }
        this.length += 1
    }
    DoublyLinkedList.prototype.get = function (position){       // 通过下标获取data
        if( position <0 || position >= this.length ) return false
        var index = 0
        var current = this.head
        while( index++ > position ){
            current = current.next
        }
        return current.next
    }
    DoublyLinkedList.prototype.indexOf = function (data){       // 通过data获取下标
        var current  = this.head
        var index = 0
        while(current){
            if(current.data == data){
                return index
            }
            current  = current.next
            index += 1
        } 
        return -1 
    }
    DoublyLinkedList.prototype.update = function( position, newData){
        if(position < 0 || pisition >= this.length ) return false
        var current = this.head
        var index = 0;
        while( index++ < position){
            current = current.next
        }
        current.data = newData
        return true
    }
    DoublyLinkedList.prototype.removeAt = function(){
        if( position < 0 || position >= this.length) return null
        var current = this.head
        if(this.length  == 1){
            this.head = null
            this.tail = null
        }else{
            if(position == 0){
                this.head.next.prev = null
                this.head = this.head.next
            }else if(positoin == this.length -1){
                current = this.tail
                this.tail.prev.next = null
                this.tail = this.tail.prev
            }else {
                var index = 0
                while(index++ < position>){
                    current = current.next
                }
                current.prev.next = current.next
                current.next.prev = current.prev
            }
            this.length  -= 1
            return current.data
        }
    }
    DoublyLinkedList.prototype.remove = function(){
        var index = this.indexOf(data)
        return this.removeAt(index)
    }
    DoublyLinkedList.prototype.size = function(){
        return this.length
    }
    DoublyLinkedList.prototype.getHead = function(){
        return this.head.data
    }
}



```

## 集合 

```js
function Set(){
    this.items = {}
    Set.prototype.add = function (value){
        if(this.has(value)){
            return false
        }
        this.items[value] = value
        return true
    }
    Set.prototype.has = function (value){
        return this.items.hasOwnProperty(value)
    }
    Set.prototype.remove = function (value){
        if(!this.has(value)) return false
        delete this.items[value]
        return true
    }
    Set.prototype.clear = function (){
        this.items = {}
    }
    Set.prototype.size = function (){
        return Object.keys(this.items).length
    }
    Set.prototype.values = function (){
        return Object.keys(this.items)
    }
    Set.prototype.union = function ( otherSet ){  // 并集
        var unionSet = new Set()
        var values = this.values()
        for(var i=0; i<values.length; i++){
            unionSet.add(values[i])
        }
        values = otherSet.values()
         for(var i=0; i<values.length; i++){
            unionSet.add(values[i])
        }
        return unionSet
    }
    Set.prototype.intersection = function (otherSet){   // 交集
        var intersetionSet = new Set()
        var values = this.values()
        for( var i = 0 ; i < value.length ; i++){
            var item = value[i]
            if(otherSet.has(item)){
                intersetionSet.add(item)
            }
        }
        return intersetionSet
    }
    Set.prototype.difference = function (otherSet){   // 差集
        var differenceSet = new Set()
        var values = this.values()
        for( var i = 0 ; i < value.length ; i++){
            var item = value[i]
            if(!otherSet.has(item)){
                differenceSet.add(item)
            }
        }
        return differenceSet
    }
    Set.prototype.subset = function (otherSet){
        var values = this.values()
        for(var i = 0; i< values.length; i++){
            var item = value[i]
            if( !otherSet.has(item)){
                return false
            }
        }
        return true
    }
}


```

## 哈希表

哈希表的结构是数组，但是他神奇的地方在于对下标值得一种变化，这种变换我们可以称之为哈希函数，通过哈希函数可以获取到HashCode。

哈希表示基于数组进行实现的，但是相对于数组，他有很多优势。

+ 他可以土工非常快速的插入-删除-查找操作。

+ 无论多少数据，插入和删除需要接近常量的事件“即：O(1)的时间级，实际上。只需要几个机器指令即可完成。

+ 哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。

+ 哈希表相对于树来说编码要容易多了。

相对于数组也有一些不足

+ 哈希表的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。

+ 通常情况下，哈希表中的key是不允许重复的，不能放置相同的key，用于保存不同的元素。

