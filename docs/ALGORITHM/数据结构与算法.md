---
sidebar: auto
---


# 数据结构与算法

## 什么是数据结构和算法

::: tip
数据结构是计算机中存储、组织数据的方式。通常情况下，精心选择的数据结构可以带来最优的算法。 ---- 中文维基百科
:::

## 为什么要学习算法和数据结构

首要原因是数据结构和算法可以很高效额解决常见的问题，这对你今后所写的代码的质量至关重要（也包括性能，用了不恰当的数据结构和算法，很可能产生性能问题）。

## 数组

几乎所有的变成语言都原生的支持数组类型。因为数组是最简单的内存数据结构。

## 栈数据结构

通过上一节我们知道，可以在数组的任意位置添加或删除元素。然而，有时候还需要一种能在添加或删除元素时进行更多的控制的数据结构。

栈是一种遵从先进后出原则的有序集合。其限制是仅允许字表的一端进行插入和删除运算，这一段称之为栈底，新添加的元素或待删除的元素都保存在栈的同一端，称之为栈顶。在栈里，新元素都靠近栈顶，旧元素都靠近栈底。


::: tip
现实中的例子：

现实生活中就像一堆垒起来的书。 新增书本或拿走书本都是从顶端添加或拿走。 

自助餐的托盘，最新放上去，最先让客人拿走使用
:::

### 程序中什么是使用栈实现的呢？
> 学了这么久的编程，是否听说过函数调用栈、
>
> 我们知道函数之间互相调用，A调用B，B调用C，C调用D
>
> 那么在指定过程中，会先将A压入栈，A没执行完，所以不会弹出栈
>
> 在A执行中调用B，那么会将B压入到栈，这时候B在栈顶，A在栈底
>
> 如果这个时候B执行完，那么B会弹出栈，但是B没有执行完呢？那他就会调用C
>
> 所以C会压栈，并且在栈顶，而C调用了D ，D会压入栈顶，
>
> 所以当前的栈执行的顺序是：栈底 A->B->C->D栈顶
>
> 执行完，弹出栈，C/B/A依次弹出栈
>
> 所以我们有函数调用栈的称呼，就是来自于他们内部的实现机制（通过栈实现的）

### 栈的面试题

有六个元素6,5,4,3,2,1，的顺序（不是一次性进栈），问下列哪一个不是合法的出战顺序（C）

+ A 5 4 3 6 1 2    
+ B 4 5 3 2 1 6   
+ C 3 4 6 5 2 1   
+ D 2 3 4 1 5 6 

### 栈结构的实现（基于数组实现）

```js
function Stack() {
    this.items = [];                        // 栈的属性 
}
Stack.prototype.push = function (value) {    // 添加一个或多个元素到栈顶
    this.items.push(value)
}
Stack.prototype.pop = function () {          // 移除栈顶元素，同时返回被移除的元素
    return this.items.pop()
}
Stack.prototype.peek = function () {         // 查看栈顶元素
    return this.items[this.items.length - 1]
}
Stack.prototype.isEmpty = function () {      // 判断栈是否为空
    return this.items.length == 0
}
Stack.prototype.clear = function () {        // 移除栈中算有的元素
    return this.items = []
}
Stack.prototype.size = function () {         // 返回栈中的个数
    return this.items.length
}
Stack.prototype.toString = function () {     // 转字符串
    let str = '';
    if(this.items.length === 0){
        return str;
    }
    for (let i = 0; i < this.items.length; i++) {
        str += item[i]
    }
    return str
}
```

### 用栈解决问题


#### 将十进制转成二进制

```js
function dec2bin(num){
    var stack = new Stack();
    while(num > 0){
        stack.push(num%2);
        num = Math.floor(num/2)
    }
    var str = '';
    while(!stack.isEmpty()){
        str += stack.pop().toString()
    }
    return str
}

```

## 队列数据结构

::: tip     受限的线性结构
符合先进先出

受限之处在于它只允许在表的前端（front）进行删除操作

而在表的后端（rear）进行插入操作。
:::

生活中有很多类似的队列结构：在银行排队办理业务，在超市排队结账，打印机打印多份资料。


### 队列结构的实现（基于数组实现）

```js
function Queue(){
    this.items = [];    // 属性
}
Queue.prototype.enqueue = function (element){   // 将元素添加到队列中
    this.items.push(element)
}
Queue.prototype.dequeue = function (){          // 从队列中删除前端元素
    this.items.shift()
}
Queue.prototype.front = function (){            // 返回队列中的第一个元素 
    return this.items[0]
} 
Queue.prototype.isEmpty = function (){          // 队列中是否为空
    return this.items.length === 0
}
Queue.prototype.size = function (){             // 返回队列包含的元素个数
    return this.items.length
}
Queue.prototype.toString = function (){         // 将队列转为字符串形式
    let str = '';
    if(this.items.length === 0){
        return str;
    }
    for (let i = 0; i < this.items.length; i++) {
        str += this.items[i]
    }
    return str
} 
```

### 击鼓传花
```js
function passGame( nameList, num){
    var queue = new Queue();                        // 创建一个队列结构
    for(var i = 0; i < nameList.elngth; i++){       // 将所有人依次加入队列
        queue.enqueue(nameList[i])
    }
    while( queue.size() > 1){
        for( var i = 0; i < num-1; i++){            // 开始数
            queue.enqueue(queue.dequeue())          // 不是num时，重新加入队列
        }
        queue.dequeue()                             // 是num时，将其从队列中删除
    }
   return queque.front()
}

```

### 优先级队列

我们知道，普通的队列插入一个元素，数据会被放在后端，并且需要前面所有的元素都处理完后才会处理前面的数据

但是优先级队列，在插入一个元素的时候会考虑该数据的优先级

和其他数据优先级比较

比较完成后，可以得出这个元素在队列中正确的位置

其他处理方式，和基本队列的处理方式一样。

```js
function PriorityQueue(){
    this.items = [];
    function QueueElement(element, priority){
        this.element = element 
        this.priorty = priority
    }
    PriorityQueue.prototype.enqueue = function (element, priority){
        var queueElement = new QueueElement(element, priority) // 创建QueueElement对象
        if(this.items.length == 0){     //  判断队列是否为空
            this.items.push(queueElement)
        }else{
            var added = false
            for(var i = 0; i < this.items.length; i++){
                if(QueueElement.priority < this.items[i].priority){
                    this.items.splice(i, 0, queueElement)
                    added = true
                    break
                }
            }
            if(!added){
                this.items.push(queueElement)
            }
        }
    }
}
PriorityQueue.prototype.enqueue = function (element){   // 将元素添加到队列中
    this.items.push(element)
}
PriorityQueue.prototype.dequeue = function (){          // 从队列中删除前端元素
    this.items.shift()
}
PriorityQueue.prototype.front = function (){            // 返回队列中的第一个元素 
    return this.items[0]
} 
PriorityQueue.prototype.isEmpty = function (){          // 队列中是否为空
    return this.items.length === 0
}
PriorityQueue.prototype.size = function (){             // 返回队列包含的元素个数
    return this.items.length
}
PriorityQueue.prototype.toString = function (){         // 将队列转为字符串形式
    let str = '';
    if(this.items.length === 0){
        return str;
    }
    for (let i = 0; i < this.items.length; i++) {
        str += this.items[i].element + '-' + this.items[i].priority + ' '  
    }
    return str
} 

```

## 链表

### 介绍

链表和数组一样，用于存储一系列的元素，但是链表和数组的实现机制完全不同。

::: tip     数组的缺点
在数组开头或中间位置插入数据的成本很高，需要进行大量元素的位移。
:::

::: tip     链表的优势
链表中的元素在内存中不必是连续的空间，链表的每个元素由一个存储元素本身的节点和一个指向下一个元素的引用组成。可以充分利用计算机的内存，实现灵活的内存动态管理。

链表不必在创建时就确定大小，并且大小可以无限的衍生下去

链表在插入和删除数据时，时间复杂度可以达到O(1)，相对于数组效率高很多。
:::

::: tip     链表的缺点
链表访问任何一个位置的元素时，都需要从头开始访问（无法跳过第一个元素访问任何一个元素）

无法通过下标直接访问元素，需要从头一个个访问，直接找到对应的元素。
:::

### 链表的实现

```js
function LinkedList(){
    function Node(data){
        this.data = data
        this.next = null
    }
    this.head = null 
    this.length = 0

    LinkedList.prototype.append = function (data){      // 向列表尾部添加一个新的项
        var newNode = new Node(data) 
        if(this.length == 0){   // 是第一个节点 
            this.head = newNode
        } else {
            var current = this.head
            while(current.next){
                current  = current.next
            }
            current.next = newNode
        }
        this.length += 1
    }
    LinkedList.prototype.insert = function (position, data){  // 向列表特定位置添加一个项
        if(position < 0 || position > this.length){
            return false
        }
        var newNode = new Node(data)

        if( position == 0){
            newNode.next = this.head 
            this.head = newNode 
        } else {
            var current = this.head     
            var index = 0
            var previous = null     
            while( index++ < position){
                previous = current  // 当前项
                current = current.next  // 当前项的下一项
            }
            newNode.next = current  // 将插入项的next指向之前在position位置项
            previous.next = newNode // 将 position位置上一项指向插入项
        }
        this.length += 1
        return true
    }
    LinkedList.prototype.get = function (position){         // 获取对应位置的元素
        if( postion <  0 || position >= this.length){
            return null
        }
        var current = this.head
        var index = 0
        while(index++ < position){
            current = current.next
        }
        return current
    }
    LinkedList.prototype.indexOf = function (data){     // 返回元素在位置中的索引，没有就返回 -1
        var current = this.head
        var index = 0 
        while(current){
            if(current.data != data){
                current = current.next
                index++
            }else{
                return index 
            }
           
        }
        return   -1
    }
    LinkedList.prototype.update = function (position, newData){      // 修改某个位置的元素
        if(position < 0 || position >= this.length) return false
        var current = this.head
        var index = 0 
        while(index++ < postion){
            current = current.next
        }
        current.data = newData
        return true
    }
    LinkedList.prototype.removeAt = function (position){    // 从列表中特定的位置移除一项
        if(position < 0 || position >= this.length) return false
        var current = this.head
        var previous = null
        var index = 0
        while(index++ < position){
            previous = current
            current = current.next  // 当前项
        } 
        previous.next = current.next
        this.length -= 1
        return true 
    }
    LinkedList.prototype.remove = function (data){      // 从列表中移除一项
        var position = this.indexOf(data)
        return this.removeAt(position)
    }
    LinkedList.prototype.isEmpty = function (){     // 链表中是否不包含任何元素
        return this.length === 0
    }
    LinkedList.prototype.size = function (){        // 返回链表包含元素的个数
        return this.length
    }
    LinkedList.prototype.toString = function (){    // 向列表尾部添加一个新的项
        var current = this.head
        var listString = ""
        while(current){
            listString += current.data
            current  = current.next  + ' '
        } 
        return  listString
    } 
}


```
 

## 双向链表

单项链表：

+ 只能从头到尾遍历

+ 实现的原理是上一个链表有一个指向下一个的引用

单向链表的缺点

+ 我们可以轻松的到达下一个节点，但是回到上一个节点是很难的；但是，在实际开发中经常会员到需要回到上一个节点的情况。


双向链表优点：

+ 既可以从头到尾遍历，也可以从尾到头遍历

双向链表缺点：

+ 每次插入或删除某个节点时，需要处理四个引用，而不是两个，实现起来比较困难

+ 相对于单向链表，占用内用空间更大 


```js
function DoublyLinkedList(){
    function Node(data){
        this.data = data
        this.prev = null
        this.next = null
    }
    this.head = null
    this.tail = null
    this.length = 0

    DoublyLinkedList.prototype.append = function (data){
        var newNode = new Node(data)
        if(this.length == 0){
            this.head = newNode
            this.tail = newNode
        }else{
            newNode.prev = this.tail
            this.tail.next = newNode
            this.tail = newNode
        }
        this.length += 1
    } 
    DoublyLinkedList.prototype.toString = function (){          
        return this.backwardString()
    }
    DoublyLinkedList.prototype.forwardString = function (){
        var current =this.tail
        var resultString = ''
        while(current){
            resultString += current.data+ ' '
            current = crrent.prev
        }
        return resultString
    }
    DoublyLinkedList.prototype.backwardString = function (){
        var current =this.head
        var resultString = ''
        while(current){
            resultString += current.data+ ' '
            current = crrent.next
        }
        return resultString
    }
    DoublyLinkedList.prototype.insert = function (position, data){      // 在指定位置插入数据
        if( position < 0 || position > this.length) return false
        var newNode = new Node(data)
        if(this.length === 0){
            this.head = newNode
            this.tail = newNode
        }else{
            if( position === 0){    // 在头部插入
                this.head.prev = newNode
                newNode.next = this.head
                this.head = newNode
            }else if(position == this.length){  // 在最后尾部插入
                this.tail.next.next = newNode
                newNode.prev = this.tail.next
                this.tail = newNode
            }else {
                var current = this.head
                var previous = null
                var index = 0
                while(index++ < position){
                    previous = current
                    current = current.next
                }
                newNode.next = current
                current.prev = newNode
                previous.next = newNode
                newNode.prev = previous
            } 
        }
        this.length += 1
    }
    DoublyLinkedList.prototype.get = function (position){       // 通过下标获取data
        if( position <0 || position >= this.length ) return false
        var index = 0
        var current = this.head
        while( index++ > position ){
            current = current.next
        }
        return current.next
    }
    DoublyLinkedList.prototype.indexOf = function (data){       // 通过data获取下标
        var current  = this.head
        var index = 0
        while(current){
            if(current.data == data){
                return index
            }
            current  = current.next
            index += 1
        } 
        return -1 
    }
    DoublyLinkedList.prototype.update = function( position, newData){
        if(position < 0 || pisition >= this.length ) return false
        var current = this.head
        var index = 0;
        while( index++ < position){
            current = current.next
        }
        current.data = newData
        return true
    }
    DoublyLinkedList.prototype.removeAt = function(){
        if( position < 0 || position >= this.length) return null
        var current = this.head
        if(this.length  == 1){
            this.head = null
            this.tail = null
        }else{
            if(position == 0){
                this.head.next.prev = null
                this.head = this.head.next
            }else if(positoin == this.length -1){
                current = this.tail
                this.tail.prev.next = null
                this.tail = this.tail.prev
            }else {
                var index = 0
                while(index++ < position>){
                    current = current.next
                }
                current.prev.next = current.next
                current.next.prev = current.prev
            }
            this.length  -= 1
            return current.data
        }
    }
    DoublyLinkedList.prototype.remove = function(){
        var index = this.indexOf(data)
        return this.removeAt(index)
    }
    DoublyLinkedList.prototype.size = function(){
        return this.length
    }
    DoublyLinkedList.prototype.getHead = function(){
        return this.head.data
    }
}



```

## 集合 

```js
function Set(){
    this.items = {}
    Set.prototype.add = function (value){
        if(this.has(value)){
            return false
        }
        this.items[value] = value
        return true
    }
    Set.prototype.has = function (value){
        return this.items.hasOwnProperty(value)
    }
    Set.prototype.remove = function (value){
        if(!this.has(value)) return false
        delete this.items[value]
        return true
    }
    Set.prototype.clear = function (){
        this.items = {}
    }
    Set.prototype.size = function (){
        return Object.keys(this.items).length
    }
    Set.prototype.values = function (){
        return Object.keys(this.items)
    }
    Set.prototype.union = function ( otherSet ){  // 并集
        var unionSet = new Set()
        var values = this.values()
        for(var i=0; i<values.length; i++){
            unionSet.add(values[i])
        }
        values = otherSet.values()
         for(var i=0; i<values.length; i++){
            unionSet.add(values[i])
        }
        return unionSet
    }
    Set.prototype.intersection = function (otherSet){   // 交集
        var intersetionSet = new Set()
        var values = this.values()
        for( var i = 0 ; i < value.length ; i++){
            var item = value[i]
            if(otherSet.has(item)){
                intersetionSet.add(item)
            }
        }
        return intersetionSet
    }
    Set.prototype.difference = function (otherSet){   // 差集
        var differenceSet = new Set()
        var values = this.values()
        for( var i = 0 ; i < value.length ; i++){
            var item = value[i]
            if(!otherSet.has(item)){
                differenceSet.add(item)
            }
        }
        return differenceSet
    }
    Set.prototype.subset = function (otherSet){
        var values = this.values()
        for(var i = 0; i< values.length; i++){
            var item = value[i]
            if( !otherSet.has(item)){
                return false
            }
        }
        return true
    }
}


```

## 哈希表

哈希表的结构是数组，但是他神奇的地方在于对下标值得一种变化，这种变换我们可以称之为哈希函数，通过哈希函数可以获取到HashCode。

哈希表示基于数组进行实现的，但是相对于数组，他有很多优势。

+ 他可以土工非常快速的插入-删除-查找操作。

+ 无论多少数据，插入和删除需要接近常量的事件“即：O(1)的时间级，实际上。只需要几个机器指令即可完成。

+ 哈希表的速度比树还要快，基本可以瞬间查找到想要的元素。

+ 哈希表相对于树来说编码要容易多了。

相对于数组也有一些不足

+ 哈希表的数据是没有顺序的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素。

+ 通常情况下，哈希表中的key是不允许重复的，不能放置相同的key，用于保存不同的元素。

哈希化：将大数字转化为数字范围内下标的过程，我们就称之为哈希化

哈希函数：通常我们会将单词转为大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们称之为哈希函数

哈希表：最终将数据插入到的这个数组，对整个结构的封装，我们称之为一个哈希表

再哈希法：

+ 二测探测的算法产生的探测序列步长是固定的，1,4,9,16，以此类推
+ 现在需要一种方法：产生一种依赖关键字的探测序列，而不是每个关键字都是一样
+ 那么，不同的关键字及时映射到相同的数组下标，也可以使用不同的探测序列
+ 再哈希的做法就是：把关键字用到另一个哈希函数，再一次哈希化，用这次哈希化的结果作为步长
+ 对于指定的关键字，步长在整个探测规则中是不变的，不过不同的关键字使用不同的步长

第二次哈希化需要具备以下特点：

+ 和第一个哈希函数不同
+ 不能输出为0


```js 哈希函数
/*
    设计hash函数
    1. 将字符串转为比较大的数字：hashCode
    2. 将大的数字hashCode压缩到数组范围（大小）之内
*/
    function hashCode(str, size){
        // 1. 定义hashCode 变量
        var hashCode = 0
        /*
            霍纳算法，来计算hashCode的值
            cats -> Unicode编码
        */
        for(var i =0; i < str.length; i++){
            hsahCode = 37 * hashCode + str.charCodeAt(i)
        }

        // 取余操作
        var index = hashCode % size
        return index
    }

```

```js  哈希表
    function HashTable() {
        this.storage = []   // 数组中存放相关的元素
        this.count = 0      // 当前存放的元素长度
        this.limit = 7      // 用于标记数组中一共可以存放多少个元素

        HashTable.prototype.hashFunc =  function (str, size){   // 哈希函数
            // 1. 定义hashCode 变量
            var hashCode = 0 
            // 霍纳算法，来计算hashCode的值
            // cats -> Unicode编码 
            for(var i =0; i < str.length; i++){
                hsahCode = 37 * hashCode + str.charCodeAt(i)
            }

            // 取余操作
            var index = hashCode % size
            return index
        }
        HashTable.prototype.put = function (key, value){    // 插入&删除操作
            var index = this.hashFunc(key,this.limit)  // 根据key获取对应的index
            var bucket = this.storage[index] // 根据index取出对应的bucket
            if(bucket == null ){
                bucket =[]
                this.storage[index] = bucket
            }
            for(var i = 0 ; i <bucket.length; i++){
                var tuple = bucket[i]
                if(tuple[0] == key){
                        tuple[1] = value
                        return 
                }
            }
            bucket.push([key,value])
            this.count += 1
        }
    }

```

。。。。。 待续

## 树

### 二叉树

如果树中么个节点最多只有两个子节点，这样的树就称之为二叉树。

一个二叉树第i层的最大节点数： 2^(i-1)

深度为k的二叉树有最大节点总数为：2^k-1

对于任何非空二叉树T，若n0表示叶节点的个数，n2是度为2的非节点个数，那么两者满足关系n0 = n2 + 1


完全二叉树

+ 除二叉树最后一层外，其他各层的节点数都达到最大个数

+ 且最后一层从左往右的叶节点连续存在，只缺右侧若干个节点

+ 完美二叉树是特殊的完全二叉树

完美二叉树

+ 每一层的节点都达到最大个数

二叉树的存储

常见的存储方式是数组和链表

+ 完全二叉树，
    + 使用数组：按从上至下，从左往右顺序存储

+ 非完全二叉树
    + 非完全二叉树要转成完全二叉树才可以按照上面的方案存储
    + 但是会造成很大的空间浪费

### 二叉搜索树 BST

二叉搜索树是一颗二叉树，可以为空。

如果不为空，满足以下条件

+ 非空左子树的所有键值小于其根节点的键值

+ 非空右子树的所有键值大于其根节点的键值

+ 左、右字数本身也是二叉搜索树

```js
class Node {
    constructor(key) {
        this.key = key
        this.left = null
        this.right = null
    }
}

class BinarySearchTree {
    constructor() {
        this.root = null            // 根节点
    } 
    insert(key) {   // 插入元素
        if (this.root == null) {
            this.root = new Node(key)
        } else {
            this.insertNode(this.root, key)
        }
    }
    insertNode(root, key) {
        if (key < root.key) {      // key 小于根节点， 应 向左查找存放
            if (root.left == null) {
                root.left = new Node(key)
            } else {
                this.insertNode(root.left, key)
            }
        } else {
            if (root.right == null) {
                root.right = new Node(key)
            } else {
                this.insertNode(root.right, key)
            }
        }
    }
    preOrderTraverse(callback) {    // 先序遍历 （先遍历节点本身，在访问它的左侧节点，最后是右侧节点）
        this.preOrderTraverseNode(this.root, callback)
    }
    preOrderTraverseNode(node, callback) {
        if (node != null) {
            callback(node)
            this.preOrderTraverseNode(node.left, callback)
            this.preOrderTraverseNode(node.right, callback)
        } 
    }
    inOrderTraverse(callback) {  // 中序遍历（先访问它的左侧节点，在遍历节点本身，最后是右侧节点）： 结果是从小到大排序
        this.inOrderTraverseNode(this.root, callback)
    }
    inOrderTraverseNode(node, callback) {
        if (node != null) { 
            this.inOrderTraverseNode(node.left, callback)
            callback(node)
            this.inOrderTraverseNode(node.right, callback)
        } 
    }
    postOrderTraverse(callback) {   // 后续遍历：先访问节点的后台节点，在访问节点本身（计算一个目录及其子目录中所有文件所占的空间）
        this.postOrderTraverseNode(this.root, callback)
    }
    postOrderTraverseNode(node, callback) {
        if (node != null) { 
            this.postOrderTraverseNode(node.left, callback)            
            this.postOrderTraverseNode(node.right, callback)
            callback(node)
        } 
    }
    min(){  // 搜索最小值
        if(this.root != null){
            let node = this.root
            while(node.left != null ){ 
                node = node.left
            }
            return node 
        }
    }
    max(){  // 搜索最大值
        if(this.root != null){
            let node = this.root
            while(node.right != null ){ 
                node = node.right
            }
            return node 
        }
    }
    search(value) {
        if (this.root != null) {
            return this.searchNode(this.root, value)
        } else {
            return false
        }
    }
    searchNode(node, value) {
        if (node.key == value) {
            return true
        } else if (value < node.key) {
            if (node.left != null) {
                return this.searchNode(node.left, value)
            } else {
                return false
            }
        } else {
            if (node.right != null) {
                return this.searchNode(node.right, value)
            } else {
                return false
            }
        }
    }
    remove(key) { 
        this.root = this.removeNode(this.root, key) // 重写二叉树
    }
    removeNode(node, key) {
        if (node == null) {  // 如果节点是空的
            return node
        }
        if (key < node.key) {   // 当删除节点 小于当前节点 ，则继续向右节点查找删除
            node.left = this.removeNode(node.left, key)
            return node
        } else if (node.key < key) {     // 当删除节点 大于当前节点 ，则继续向右节点查找删除
            node.right = this.removeNode(node.right, key)
            return node
        } else {  // 当查找到要删除的节点
            if (node.left == null && node.right == null) {   //被删除的节点没有子节点
                node = null
                return node
            } else if (node.left == null) {  // 当被删除的数据只有一个右节点时
                node = node.right
                return node
            } else if (node.right == null) {  // 当被删除的数据只有一个左节点时
                node = node.left
            } else {  // 当被删除的节点拥有两个子节点时 
                let min = node.right  // 1. 查找后继 （后继：右子树的最小值，前驱：左子树的最大值）
                while (min.left) {
                    min = min.left
                } 
                node.key = min.key  // 2.将后继替换被删除的节点
                node.right = this.removeNode(node.right, min.key)   // 将后继删除
                return node

            }
        }  
    } 
}
```
 测试代码
```js  
let tree = new BinarySearchTree()
tree.insert(11)
tree.insert(7)
tree.insert(15)
tree.insert(5)
tree.insert(3)
tree.insert(9)
tree.insert(8)
tree.insert(10)
tree.insert(13)
tree.insert(12)
tree.insert(14)
tree.insert(20)
tree.insert(18)
tree.insert(25)
tree.insert(6)
console.log(tree)
tree.preOrderTraverse(function ( node){
    console.log(node.key)
})
tree.inOrderTraverse(function ( node){
    console.log(node.key)
})
tree.postOrderTraverse(function ( node){
    console.log(node.key)
})
console.log(tree.min())
console.log(tree.max())
console.log(tree.search(10))
console.log(tree.remove(11))
```

## 红黑树

+ 1. 节点是黑色或者红色
+ 2. 跟节点是黑色
+ 3. 每个叶子节点都是黑色的空节点（NULL节点）
+ 4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 
+ 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

插入一个新节点，有可能树不再平衡，可以通过三种方式的变换，让树保持平衡。

+  换色 -- 左旋转 -- 右旋转

插入的新节点都是红色

左旋转： 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代。而自己成为自己的左孩子。

右旋转： 顺市政旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为原左孩子的右孩子